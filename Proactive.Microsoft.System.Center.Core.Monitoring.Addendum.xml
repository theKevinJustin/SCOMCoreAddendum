<?xml version="1.0" encoding="utf-8"?><ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <Manifest>
    <Identity>
      <ID>Proactive.Microsoft.System.Center.Core.Monitoring.Addendum</ID>
      <Version>1.0.2.4</Version>
    </Identity>
    <Name>Proactive Microsoft System Center Core Monitoring Addendum</Name>
    <References>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSCNL">
        <ID>Microsoft.SystemCenter.Notifications.Library</ID>
        <Version>7.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MSIGL">
        <ID>Microsoft.SystemCenter.InstanceGroup.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SCCM">
        <ID>Microsoft.SystemCenter.2007</ID>
        <Version>7.1.10000.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SystemCenter">
        <ID>Microsoft.SystemCenter.OperationsManager.DataAccessService</ID>
        <Version>7.2.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <EntityTypes>
      <ClassTypes>
        <ClassType ID="Proactive.High.Agent.Handle.Count.Servers.Group" Accessibility="Public" Abstract="false" Base="MSIGL!Microsoft.SystemCenter.InstanceGroup" Hosted="false" Singleton="true" Extension="false" />
      </ClassTypes>
    </EntityTypes>
    <ModuleTypes>
      <DataSourceModuleType ID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:31</Start>
                        <End>06:51</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Datasource.v1024.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather SCOMCore alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Datasource.v1024.ps1"
$EventID = "630"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting.  Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}
	
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather SCOMCore Alerts for date ($date).")
$Message = "Proactive DailyTasks SystemCenter Core Monitoring alerts for ($date)"

# Gather SCOMCore alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "System Center Core Monitoring"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreRuleAlerts

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMOpenReportAlerts = $SCOMCoreReportAlerts | ? { ( $_.ResolutionState -ne "255" ) }
$SCOMOpenReportAlerts.Count

$SCOMClosedReportAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -OR ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMClosedReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

$AutoClosed = $SCOMCoreMonitorAlerts.Count + $SCOMCoreRuleAlerts.Count
$Test = $SCOMCoreReportAlerts.Count


$momapi.LogScriptEvent($ScriptName,$EventID,0,"SCOMCore alerts gathered for ($date).")


# Agent resources alerts
$AgentResources = $SCOMCoreMonitorAlerts | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost*" ) }
$AgentResources.Count

if ( $AgentResources.Count -gt 0 )
	{
	# All
	$AgentResourcesFormatted = $AgentResources | ft TimeRaised,NetbiosComputerName,Description -auto -wrap
	# Break out variants MonitoringHost Private Bytes/Handle Count
	$PrivateBytes = $AgentResources | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost Private Bytes*" ) }
	$PrivateBytes.Count
	$HandleCount = $AgentResources | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost Handle Count*" ) }
	$HandleCount.Count

	# Operations Manager failed alerts
	$OpsMgrfailedAlerts = $SCOMCoreAlertsSinceLastReport | ? { ( $_.Name -like "Operations Manager failed*" ) `
		-AND ( $_.Description -like "*The paging file is too small*" )
		}
	$OpsMgrfailedAlerts.Count
	#$OpsMgrfailedAlerts | ft TimeRaised,NetbiosComputerName -auto -wrap
	}
	
# Debug - Tally and build display of $SCOMCoreReportAlerts
#$SCOMCoreAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,Description

# NOT Monitored server alerts
$NOTMonitoredServers = $SCOMCoreMonitorAlerts | ? { ( $_.Name -eq "Health Service Heartbeat Failure" ) }
$NOTMonitoredServers.Count

# Remaining alerts
$Remaining = @()
$Remaining = $SCOMCoreMonitorAlerts | ? { ( $_.Name -ne "Health Service Heartbeat Failure" ) `
	-AND ( $_.Name -notlike "Agent Resources Exceeded Threshold: MonitoringHost*" ) `
	}
$Remaining.Count

	
#
# Create table output	
$SCOMCoreServerAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,TimeRaised,Name

#
# Create table output (no description)	
$SCOMCoreServerAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,TimeRaised,Name

$Test = $SCOMCoreServerAlerts.count


#
# Build report
$SCOMCoreAMessage = @()


if ( $SCOMCoreReportAlerts.count -eq 0 )
	{
	$Message = "ZERO SCOMCore Monitors auto-closed for ($date)"
	$SCOMCoreAMessage += "ZERO SCOMCore Monitors auto-closed for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}


if ( $SCOMCoreReportAlerts.count -gt 0 )
	{
	$SCOMCoreAMessage += $Message
	$SCOMCoreAMessage += ""
	$SCOMCoreAMessage += "Alert Count = $Test "
	$SCOMCoreAMessage += ""
	$SCOMCoreAMessage += "# SCOMCore Monitors auto-closed"
	$SCOMCoreAMessage += "#=========================================================="
	$SCOMCoreAMessage += "# ALL SCOMCore alerts = $($SCOMCoreReportAlerts.Count)"
	$SCOMCoreAMessage += "#"
	$SCOMCoreAMessage += "# SCOMCore alerts since last report = $($SCOMCoreAlertsSinceLastReport.Count)"
	$SCOMCoreAMessage += "#"
	$SCOMCoreAMessage += "# Open SCOMCore alerts = $($SCOMOpenReportAlerts.Count)"
	$SCOMCoreAMessage += "# Closed SCOMCore alerts = $($SCOMClosedReportAlerts.Count)"
	$SCOMCoreAMessage += "#=========================================================="
	$SCOMCoreAMessage += "#"

	if ( $AgentResources.Count -gt 0 )
		{
		$SCOMCoreAMessage += "# Agent Resources alert breakdown"
		$SCOMCoreAMessage += "#================================================"
		$SCOMCoreAMessage += "# Agent Private Bytes alerts = $($PrivateBytes.Count)"
		$SCOMCoreAMessage += "# Agent Handle Count alerts = $($HandleCount.Count)"
		$SCOMCoreAMessage += "#"

		if ( ( $HandleCount.Count -gt 0 ) -AND ( $HandleCount.count -le 10 ) )
			{
			$SCOMCoreAMessage += "# Handle Count details"
			$SCOMCoreAMessage += $HandleCount | sort -property TimeRaised -desc | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( $HandleCount.Count -gt 10 )
			{
			$SCOMCoreAMessage += "More than 10 handle count alerts for report run get-scomalert for ALL details"
			$SCOMCoreAMessage += "First 10 alerts displayed"
			$SCOMCoreAMessage += $HandleCount | sort -property TimeRaised -desc | select -first 10 | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( ( $PrivateBytes.Count -gt 0 ) -AND ( $PrivateBytes.Count -le 10 ) )
			{
			$SCOMCoreAMessage += "# Private Bytes agent alert details"
			$SCOMCoreAMessage += $PrivateBytes | sort -property TimeRaised -desc | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( $PrivateBytes.Count -gt 10 )
			{
			$SCOMCoreAMessage += "More than 10 private byte alerts for report run get-scomalert for more details"
			$SCOMCoreAMessage += "First 10 alerts displayed"
			$SCOMCoreAMessage += $PrivateBytes | sort -property TimeRaised -desc | select -first 10 | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		}
		if ( $OpsMgrfailedAlerts -gt 0 )
			{
			$SCOMCoreAMessage += "# OperationsManager and 'paging file is too small' alerts"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += $OpsMgrfailedAlerts | ft TimeRaised,NetbiosComputerName -auto -wrap | out-string
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			}
		if ( $Remaining.Count -gt 0 )
			{
			$SCOMCoreAMessage += "# Remaining alerts not classified"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += $Remaining | ft TimeRaised,MonitoringObjectDisplayName,Name -auto -wrap | out-string
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			}
		if ( $NOTMonitoredServers.Count -gt 0 )
			{
			$SCOMCoreAMessage += "# 'NOT monitored servers"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += "# 'NOT monitored server count = $($NOTMonitoredServers.Count)"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			if ( $NOTMonitoredServers.Count -gt 20 )
				{
				$SCOMCoreAMessage += "# 'NOT monitored servers greater than 20"
				}
			if ( $NOTMonitoredServers.Count -lt 20 )
				{
				$SCOMCoreAMessage += "# 'NOT monitored server detail"			
				$SCOMCoreAMessage += "#================================================"
				$SCOMCoreAMessage += $NOTMonitoredServers | ft TimeRaised,MonitoringObjectDisplayName -auto -wrap | out-string
				$SCOMCoreAMessage += "#================================================"
				}
			$SCOMCoreAMessage += ""
		$SCOMCoreAMessage += "#================================================"
		$SCOMCoreAMessage += "#"
			}
	}

$SCOMCoreAMessage

$SCOMCoreAMessage = $SCOMCoreAMessage | out-string


#============================================================


  $Result = "GOOD"
  #$Message = "SCOMCore Monitors auto-closed for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"$SCOMCoreAMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$SCOMCoreAMessage)


# Return all bags
$bag
#============================================================


#
# If Cleanup needed, array of report monitors

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks SystemCenter Core Monitoring monitor reset begins for ($date).")


#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks SystemCenter Core Monitoring monitor reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get SCOM Core classes - $SCOMCoreMP

	# SCOMCore pack naming
	$SCOMCoreClasses = @(Get-SCOMClass -ManagementPack $SCOMCoreMP; )
	$SCOMCoreClass = $SCOMCoreClasses | sort -property Name -uniq
	# Debug
	$SCOMCoreClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $SCOMCoreClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count					
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID				
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#===================================
# $UnhealthyMonitors = $($UnhealthyMonitors | measure-object -sum).sum
#$momapi.LogScriptEvent($ScriptName,$EventID,0,"# Proactive DailyTasks SystemCenter Core Monitoring monitor reset auto-close completed on ($date).")
#=================================================================================

#
# (Rules) Alerts to auto close after reset monitor
#============================================================
# Resolve alerts after report built
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }

# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days

if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - Proactive System Center Core Monitoring Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"# Proactive System Center Core Monitoring Addendum rule closure completed for ($date).")


#=================================================================================
# End MAIN script section
 
  
# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.DS" Accessibility="Internal" Batching="false">
        <Configuration>
		  <xsd:element minOccurs="1" type="xsd:integer" name="IntervalSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="0" type="xsd:string" name="SyncTime" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:string" name="StringParamExample" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:string" name="ComputerName" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
        </Configuration>
        <OverrideableParameters>
		  <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
		  <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
		  <OverrideableParameter ID="StringParamExample" Selector="$Config/StringParamExample$" ParameterType="string" />
		  <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
					<SyncTime>$Config/SyncTime$</SyncTime>
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.DS.v1024.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Run DWDataRP tool to gather state/alert/event storage concerns on SCOM DW, and alert for space available
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================

Param (
     [Parameter(
	 	 Mandatory=$true,
         ValueFromPipeline=$true,
	 	 Position=0)]
		 [String]$StringParamExample,
     [Parameter(
	 	 Mandatory=$true,
         ValueFromPipeline=$true,
	 	 Position=1)]
		 [ValidateNotNullorEmpty()]
		 [String]$ComputerName
)

# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.  
$ScriptName = "Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.DS.v1024.ps1"
$EventID = "631"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Monitor DS Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Monitor DS Script parameters passed into datasource: `nStringParamExample: ($StringParamExample) `nComputerName: ($ComputerName).")

$date = get-date -uFormat "%Y-%m-%d"

# Tailor path - lab vs. customer
# Lab examples
# cd 'C:\MonAdmin\SCOM Tools\dwdatarp'
# d: ; cd D:\TOOLS\
# $ComputerName = "16db02"
# $DWDATARPPATH = "C:\MonAdmin\SCOM Tools\dwdatarp"

# Translate parameter to runtime, showing blank
# $StringParamExample
$DWDATARPPATH = $StringParamExample
write-host -foreground green "$DWDATARPPATH"

cd $DWDATARPPATH

# Check events
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "Event Data Set"'
$EventDataSet = Invoke-Expression $Command

$EventDataSet
$EventDataSet[2]

$LLineSplit = $EventDataSet[2].Split("(")
$EventDBPercent = $LLineSplit[1].Split("%")

$EventDBPercent[0]

if ( $($EventDBPercent[0].Split(" ")).Count -eq 1 )
	{
	write-host -foreground red "Critical Event Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical Event Data set - 100%")
	}

if ( $($EventDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Event Data set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Event Data set less than 10%")
	}

if ( $($EventDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Event Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Event Data set - between 10-99%")
	$EventActualPercent = $EventDBPercent[0].Split(" ")
	$EventActualPercent[1]
	if ( $EventActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Enabled Event rules to disable, Event Data set percent at $($EventActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Enabled Event rules to disable, Event Data set percent at $($EventActualPercent[1])")
		}
	}

# Check performance
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "Performance Data Set"'
$PerfDataSet = Invoke-Expression $Command

$PerfDataSet
$PerfDataSet[3]

$LLineSplit = $PerfDataSet[3].Split("(")
$PerfDBPercent = $LLineSplit[1].Split("%")
$PerfDBPercent[0]

if ( $($PerfDBPercent[0].Split(" ")).Count -eq 1 )
	{
	write-host -foreground red "Critical Perf Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical Perf Data set - 100%")
	}
if ( $($PerfDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Perf Data set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Perf Data set less than 10%")
	}	
	
if ( $($PerfDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Perf Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Perf Data set - between 10-99%")
	$PerfActualPercent = $PerfDBPercent[0].Split(" ")
	$PerfActualPercent[1]
	if ( $PerfActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Enabled Performance counter rules to disable, Perf Data set percent at $($PerfActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Enabled Performance counter rules to disable, Perf Data set percent at $($PerfActualPercent[1])")
		}
	}

# Check state
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "State Data Set"'
$StateDataSet = Invoke-Expression $Command

$StateDataSet
$StateDataSet[3]

$LLineSplit = $StateDataSet[3].Split("(")
$StateDBPercent = $LLineSplit[1].Split("%")
$StateDBPercent[0]
if ( $($StateDBPercent[0].Split(" ")).Count -eq 1 ) 
	{
	write-host -foreground red "Critical State Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical State Data set - 100%")
	}
if ( $($StateDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Perf State set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Perf State set less than 10%")
	}
if ( $($StateDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Perf Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Perf Data set - between 10-99%")
	$StateActualPercent = $StateDBPercent[0].Split(" ")
	$StateActualPercent[1]
	if ( $StateActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Config Churn monitors causing state issues, State Data set percent at $($StateActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Config Churn monitors causing state issues, State Data set percent at $($StateActualPercent[1])")
		}
	}

# Provide all DWDataRP output for review
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW'
$AllDWDataRPOutput = Invoke-Expression $Command
 
$AllDWDataRPOutput

# Combine output into single alert/event
$Summary = @()

$Summary += "#"
$Summary += "# DWDataRP Rule DS Script for $($date)"
$Summary += "#"
$Summary += ""
$Summary += "# Event DW retention"
$Summary += "#============================================"
$Summary += $EventDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# Performance DW retention"
$Summary += "#============================================"
$Summary += $PerfDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# State DW retention"
$Summary += "#============================================"
$Summary += $StateDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# Full DWDataRP output"
$Summary += "#============================================"
$Summary += $AllDWDataRPOutput
$Summary += "#============================================"
$Summary += ""

$DWDataRPReport = $Summary | out-string

$DWDataRPReport


# Create event and stage property bag
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$DWDataRPReport")

$Result = "BAD"
$Message = "DWDataRP Rule DS Script for $($date)"


$bag.AddValue('Result',$Result)
#$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$DWDataRPReport)


# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Monitor DS Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>StringParamExample</Name>
                    <Value>$Config/StringParamExample$</Value>									
                  </Parameter>
                  <Parameter>
                    <Name>ComputerName</Name>
                    <Value>$Config/ComputerName$</Value>									
                  </Parameter>				  
                </Parameters>				
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="IntervalSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" type="xsd:string" name="SyncTime" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />	
          <xsd:element minOccurs="1" type="xsd:string" name="StringParamExample" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:string" name="ComputerName" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
          <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
		  <OverrideableParameter ID="StringParamExample" Selector="$Config/StringParamExample$" ParameterType="string" />	  
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <SimpleReccuringSchedule>
                    <Interval Unit="Seconds">$Config/IntervalSeconds$</Interval>
					<SyncTime>$Config/SyncTime$</SyncTime>
                  </SimpleReccuringSchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Rule.DS.v1024.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Run DWDataRP tool to gather state/alert/event storage concerns on SCOM DW, and alert for space available
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================

Param (
     [Parameter(
	 	 Mandatory=$true,
         ValueFromPipeline=$true,
	 	 Position=0)]
		 [String]$StringParamExample,
     [Parameter(
	 	 Mandatory=$true,
         ValueFromPipeline=$true,
	 	 Position=1)]
		 [ValidateNotNullorEmpty()]
		 [String]$ComputerName
)

# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.  
$ScriptName = "Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Rule.DS.v1024.ps1"
$EventID = "632"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Rule DS Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Rule DS Script parameters passed into datasource: `nStringParamExample: ($StringParamExample) `nComputerName: ($ComputerName).")

$date = get-date -uFormat "%Y-%m-%d"

# Tailor path - lab vs. customer
# Lab examples
# cd 'C:\MonAdmin\SCOM Tools\dwdatarp'
# d: ; cd D:\TOOLS\
# $ComputerName = "16db02"
# $DWDATARPPATH = "C:\MonAdmin\SCOM Tools\dwdatarp"

# Translate parameter to runtime, showing blank
# $StringParamExample
$DWDATARPPATH = $StringParamExample
write-host -foreground green "$DWDATARPPATH"

cd $DWDATARPPATH

# Check events
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "Event Data Set"'
$EventDataSet = Invoke-Expression $Command

$EventDataSet
$EventDataSet[2]

$LLineSplit = $EventDataSet[2].Split("(")
$EventDBPercent = $LLineSplit[1].Split("%")

$EventDBPercent[0]

if ( $($EventDBPercent[0].Split(" ")).Count -eq 1 )
	{
	write-host -foreground red "Critical Event Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical Event Data set - 100%")
	}

if ( $($EventDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Event Data set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Event Data set less than 10%")
	}

if ( $($EventDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Event Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Event Data set - between 10-99%")
	$EventActualPercent = $EventDBPercent[0].Split(" ")
	$EventActualPercent[1]
	if ( $EventActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Enabled Event rules to disable, Event Data set percent at $($EventActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Enabled Event rules to disable, Event Data set percent at $($EventActualPercent[1])")
		}
	}

# Check performance
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "Performance Data Set"'
$PerfDataSet = Invoke-Expression $Command

$PerfDataSet
$PerfDataSet[3]

$LLineSplit = $PerfDataSet[3].Split("(")
$PerfDBPercent = $LLineSplit[1].Split("%")
$PerfDBPercent[0]

if ( $($PerfDBPercent[0].Split(" ")).Count -eq 1 )
	{
	write-host -foreground red "Critical Perf Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical Perf Data set - 100%")
	}
if ( $($PerfDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Perf Data set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Perf Data set less than 10%")
	}	
	
if ( $($PerfDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Perf Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Perf Data set - between 10-99%")
	$PerfActualPercent = $PerfDBPercent[0].Split(" ")
	$PerfActualPercent[1]
	if ( $PerfActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Enabled Performance counter rules to disable, Perf Data set percent at $($PerfActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Enabled Performance counter rules to disable, Perf Data set percent at $($PerfActualPercent[1])")
		}
	}

# Check state
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW -ds "State Data Set"'
$StateDataSet = Invoke-Expression $Command

$StateDataSet
$StateDataSet[3]

$LLineSplit = $StateDataSet[3].Split("(")
$StateDBPercent = $LLineSplit[1].Split("%")
$StateDBPercent[0]
if ( $($StateDBPercent[0].Split(" ")).Count -eq 1 ) 
	{
	write-host -foreground red "Critical State Data set - 100%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Critical State Data set - 100%")
	}
if ( $($StateDBPercent[0].Split(" ")).Count -gt 2 )
	{
	write-host -foreground green "Perf State set less than 10%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Perf State set less than 10%")
	}
if ( $($StateDBPercent[0].Split(" ")).Count -eq 2 )
	{
	write-host -foreground yellow "Verify Perf Data set - between 10-99%"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Verify Perf Data set - between 10-99%")
	$StateActualPercent = $StateDBPercent[0].Split(" ")
	$StateActualPercent[1]
	if ( $StateActualPercent[1] -gt 40 )
		{
		write-host -foreground yellow "Look for Config Churn monitors causing state issues, State Data set percent at $($StateActualPercent[1])"
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Look for Config Churn monitors causing state issues, State Data set percent at $($StateActualPercent[1])")
		}
	}

# Provide all DWDataRP output for review
$Command = '.\dwdatarp.exe -s $ComputerName -d OperationsManagerDW'
$AllDWDataRPOutput = Invoke-Expression $Command
 
$AllDWDataRPOutput

# Combine output into single alert/event
$Summary = @()

$Summary += "#"
$Summary += "# DWDataRP Rule DS Script for $($date)"
$Summary += "#"
$Summary += ""
$Summary += "# Event DW retention"
$Summary += "#============================================"
$Summary += $EventDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# Performance DW retention"
$Summary += "#============================================"
$Summary += $PerfDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# State DW retention"
$Summary += "#============================================"
$Summary += $StateDataSet
$Summary += "#============================================"
$Summary += ""
$Summary += "# Full DWDataRP output"
$Summary += "#============================================"
$Summary += $AllDWDataRPOutput
$Summary += "#============================================"
$Summary += ""

$DWDataRPReport = $Summary | out-string

$DWDataRPReport


# Create event and stage property bag
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$DWDataRPReport")

$Result = "BAD"
$Message = "DWDataRP Rule DS Script for $($date)"


$bag.AddValue('Result',$Result)
#$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$DWDataRPReport)


# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"DWDataRP Rule DS Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>StringParamExample</Name>
                    <Value>$Config/StringParamExample$</Value>									
                  </Parameter>
                  <Parameter>
                    <Name>ComputerName</Name>
                    <Value>$Config/ComputerName$</Value>									
                  </Parameter>				  
                </Parameters>					
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>07:07</Start>
                        <End>07:21</End>
                        <DaysOfWeekMask>2</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.Microsoft.SCOMMS.Window.Monitoring.FIPS.Compliance.Script.Datasource.v1024.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to check SCOM for FIPS DOTNET configuration script
#
#  Author:  Kevin Justin
#
#  Version:  1.0
#
#=================================================================================

# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging
$ScriptName = "Proactive.Microsoft.SCOMMS.Window.Monitoring.FIPS.Compliance.Script.Datasource.v1024.ps1"
#$ScriptName = "Proactive.SQL.FIPS.V-214022.WebConsole.DOTNET.Configuration.DataSource.v1024.ps1"
$EventID = "638"
#=================================================================================

# Starting Script section
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive SCOM FIPS WebConsole DOTNET Configuration Script is starting. Running as ($whoami).")
# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#$date = get-date -uFormat "%Y-%m-%d %H%M"
$date = get-date -uFormat "%Y-%m-%d"

$SCOMServer = $ENV:ComputerName

#================================================================
# Open PSEXEC -S to create PowerShell session as local system
#================================================================
#
# Test session is running as local system
#
# whoami verification.
#================================================================
if ( ( whoami | where { $_ -like "NT Authority\system" } ).Count -gt 0 )
	{
	write-host "Running as Local System"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script IS running as Local System")
	}
if ( ( whoami | where { $_ -like "NT Authority\system" } ).Count -eq 0 )
	{
	write-host "NOT Running as Local System"
	$NOTLocalSystem = ( whoami | where { $_ -like "NT Authority\system" } ).Count
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is NOT Running as Local System")
	#exit
	}


$Message = "Proactive SCOM STIG V-237439 FIPS WebConsole Configurations Script findings for $($date)"

$FIPSDOTNETConfigSettingsOutput = @()

$FIPSDOTNETConfigSettingsOutput += $Message
$FIPSDOTNETConfigSettingsOutput += ""


# Check FIPS Registry key is configured
#==========================================
$RegPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy"
[string]$FIPSEnabled = (Get-ItemProperty -Path $RegPath -Name Enabled).Enabled
$FIPSEnabled

$FIPSDOTNETConfigSettingsOutput += ""
$FIPSDOTNETConfigSettingsOutput += "# FIPS configuration verification on Server $($SCOMServer)"
$FIPSDOTNETConfigSettingsOutput += "#========================================================="

$FIPSDOTNETConfigSettingsOutput += ""
$FIPSDOTNETConfigSettingsOutput += "# FIPS Registry key verification"
$FIPSDOTNETConfigSettingsOutput += "#==============================="
	
if ( $NULL -eq $FIPSEnabled )
	{
	write-host "FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' disabled"
	$FIPSDOTNETConfigSettingsOutput += "ACTION REQUIRED: ENABLE FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy'"
	$FIPSDOTNETConfigSettingsOutput += ""
	#$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive SCOM FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' disabled")
	}

if ( $FIPSEnabled -eq "0" )
	{
	write-host "FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' enabled"
	$FIPSDOTNETConfigSettingsOutput += "ACTION REQUIRED: Enable FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy'"
	$FIPSDOTNETConfigSettingsOutput += ""
	#$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive SCOM FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' enabled")
	}
if ( $FIPSEnabled -eq "1" )
	{
	write-host "FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' enabled"
	$FIPSDOTNETConfigSettingsOutput += "FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' enabled"
	$FIPSDOTNETConfigSettingsOutput += ""
	#$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive SCOM FIPS RegKey 'HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy' enabled")
	}


# SCOM server web config file mining
#=======================================
# SCOM Install variants
$SCOMInstallPaths = @("Program Files\Microsoft System Center\Operations Manager\WebConsole","Program Files\Microsoft System Center 2016\Operations Manager\WebConsole")
# SSRS  Install variants
# $SSRSInstallPaths = @("Program Files\Microsoft SQL Server\MSRS*\Reporting Services\ReportServer","Program Files\Microsoft SQL Server Reporting Services\SSRS\ReportServer")
# Debug
#$SCOMInstallPaths
#$SCOMInstallPaths


# Logical disk list
# Validate logical disks where SCOM and SQL SSRS are installed
$LogicalDisks = gwmi win32_logicaldisk | where { $_.DeviceID -ne "A:" }
#$LogicalDisks.DeviceID

foreach ( $LogicalDisk in $LogicalDisks.DeviceID )
    {
	#write-host "Logical Disk letter = $LogicalDisk"
	foreach ( $SCOMInstallPath in $SCOMInstallPaths )
		{
		If ( $True -eq ( Test-path "$LogicalDisk\$SCOMInstallPath" ) )
			{
			$SCOMLOGDir = "$LogicalDisk\$SCOMInstallPath"
			write-host "MCM Log directory = $($SCOMLOGDir)"
			}
		}
	}

# Debug for directory names
#$SCOMLOGDir



# Check for for DOT NET Windows SDK install of gacutil.exe on server
#========================================================================
# https://blakedrumm.com/blog/verify-assemblies-loaded-with-gacutil/
# 	cd "C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools"
#	Run this GACUtil Command to List the Assemblies installed:
#	Powershell:
#	.\gacutil /L
#========================================================================

$GACUTILSearchPath = (gci "C:\Program Files (x86)\Microsoft SDKs\windows\*\bin\NETFX 4.*\gacutil.exe" -recurse)
$GACUTILSearchPath.Count

$FIPSDOTNETConfigSettingsOutput += "# FIPS GACUTIL SCOM Cryptography DLL verification"
$FIPSDOTNETConfigSettingsOutput += "#================================================"
$FIPSDOTNETConfigSettingsOutput += ""

If ( ($GACUTILSearchPath.DirectoryName).Count -eq 0 ) 
	{
	$FIPSDOTNETConfigSettingsOutput += "DOT NET Windows SDK NOT installed. Install or copy gacutil to monitoring repository path" 
	}

If ( ($GACUTILSearchPath.DirectoryName).Count -gt 0 ) 
	{
	write-host "DOT NET Windows SDK installed with gacutil.exe to register FIPS cartography dll"
	$FIPSDOTNETConfigSettingsOutput += "DOT NET Windows SDK installed"
	$FIPSDOTNETConfigSettingsOutput += ""

	# cd "C:\Program Files (x86)\Microsoft SDKs\windows\v8.1A\bin\NETFX 4.5.1 Tools\x64"
	$FIPSDOTNETConfigSettingsOutput += "Path for directory where gacutil.exe resides"
	$FIPSDOTNETConfigSettingsOutput += $GACUTILSearchPath.DirectoryName
	$FIPSDOTNETConfigSettingsOutput += ""

	cd $GACUTILSearchPath.DirectoryName[0]
	$GacutilAssemblies = (.\gacutil.exe /L)
	# $GacutilAssemblies

	$SCOMFIPSDLL = $GacutilAssemblies | where { $_ -eq "Microsoft.EnterpriseManagement.Cryptography.dll" }
	
	If ( $SCOMFIPSDLL.Count -eq 0 )
		{
		$FIPSDOTNETConfigSettingsOutput += "ACTION REQUIRED: FIPS cartography DLL NOT installed"
		$FIPSDOTNETConfigSettingsOutput += "Run 'gacutil.exe /i' with path of Microsoft.EnterpriseManagement.Cryptography.dll to register FIPS cartography dll"
		$FIPSDOTNETConfigSettingsOutput += ""
		$FIPSDOTNETConfigSettingsOutput += "# Cryptography assemblies installed on SCOM server $($SCOMServer)"
		$FIPSDOTNETConfigSettingsOutput += "#================================================================"
		$FIPSDOTNETConfigSettingsOutput += $GacutilAssemblies | where{ $_ -like "*cryptography*" }
		$FIPSDOTNETConfigSettingsOutput += "#================================================================"
		$FIPSDOTNETConfigSettingsOutput += ""
		}
	If ( $SCOMFIPSDLL.Count -eq 1 )
		{
		$FIPSDOTNETConfigSettingsOutput += "SCOM FIPS cartography DLL installed"
		$FIPSDOTNETConfigSettingsOutput += ""
		}
	}



# Check DOT NET versions machine.config for cryptography settings
#========================================================================
$FIPSDOTNETConfigSettingsOutput += "# FIPS DOTNET machine.config file verification on Server $($SCOMServer)"
$FIPSDOTNETConfigSettingsOutput += "#=================================================================================================="
$FIPSDOTNETConfigSettingsOutput += ""
$FIPSDOTNETConfigSettingsOutput += "# Backup machine.config AND audit cryptography section contained in DOT NET machine.config files"
$FIPSDOTNETConfigSettingsOutput += "#=================================================================================================="
$FIPSDOTNETConfigSettingsOutput += ""

$DOTNETVersions = $("Framework\v2.0.50727\CONFIG","Framework\v4.0.30319\Config","Framework64\v4.0.30319\Config")

# PowerShell commands, open PowerShell as Administrator
#========================================
foreach ( $DOTNETVersion in $DOTNETVersions )
	{
	cd "C:\Windows\Microsoft.NET\$DOTNETVersion"
	if ( Test-path "C:\Windows\Microsoft.NET\$DOTNETVersion" )
		{
		if ( Test-path "C:\Windows\Microsoft.NET\$DOTNETVersion\machine.config" )
			{
			if ( $NULL -eq $NOTLocalSystem )
				{
				copy machine.config machine.config.$date
				$FIPSDOTNETConfigSettingsOutput += "Backed up C:\Windows\Microsoft.NET\$DOTNETVersion\machine.config.$date"
				$FIPSDOTNETConfigSettingsOutput += ""
				}
			}

		if ( Test-path "C:\Windows\Microsoft.NET\$DOTNETVersion\machine.config.202*" )
			{
			#copy machine.config machine.config.$date
			$FIPSDOTNETConfigSettingsOutput += "machine.config backup exists"
			}
		}

	# Audit SCOM web.config files
	#========================================

	# Check SCOM Console Monitoring View web.config file
	#========================================================================
	# Long path
	# If ( test-path "D:\Program Files\Microsoft System Center\Operations Manager\WebConsole\MonitoringView" )
	# If ( test-path "D:\Program Files\Microsoft System Center\Operations Manager\WebConsole\$website )
	#========================================================================

	$FIPSDOTNETConfigSettingsOutput += "# Individual SCOM Applications web.config file configuration audit"
	$FIPSDOTNETConfigSettingsOutput += "#================================================================="
	$FIPSDOTNETConfigSettingsOutput += ""

	# Comment out unneeded
	#========================
	# $SCOMIISWebsites = $("AppDiagnostics\Web","Dashboard","MonitoringView","$SSRSLOGDir")
	$SCOMIISWebsites = $("MonitoringView")
	$SCOMIISWebsites

	foreach ( $website in $SCOMIISWebsites )
		{
		If ( test-path "$SCOMLOGDir\$website" )
			{
			cd "$SCOMLOGDir\$website"
			}
		If ( test-path "$SCOMLOGDir\$website\web.config" )
			{
			# Audit for cryptography DLL
			#========================================
			$AuditMachineConfig = gc web.config | select-string -pattern "Microsoft.EnterpriseManagement.Cryptography"

			if ( $NULL -eq $AuditMachineConfig )
				{
				$FIPSDOTNETConfigSettingsOutput += "ACTION REQUIRED: Missing Microsoft.EnterpriseManagement.Cryptography DLL configuration"
				$FIPSDOTNETConfigSettingsOutput += "File Location = C:\Windows\Microsoft.NET\$DOTNETVersion"
				$FIPSDOTNETConfigSettingsOutput += ""
				If ( $null -ne ( gc web.config | select-string -pattern "cryptoClass" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# CryptoClass strings found in machine.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "cryptoClass"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			if ( $NULL -ne $AuditMachineConfig )
				{
				$FIPSDOTNETConfigSettingsOutput += "Microsoft.EnterpriseManagement.Cryptography DLL configuration"
				$FIPSDOTNETConfigSettingsOutput += "File Location = C:\Windows\Microsoft.NET\$DOTNETVersion"
				$FIPSDOTNETConfigSettingsOutput += ""
				}

			# Check for configuration entries
			#================================
			if ( $website -ne "$SSRSLOGDir" )
				{
				$FIPSDOTNETConfigSettingsOutput += "# SCOM Web Application"
				$FIPSDOTNETConfigSettingsOutput += "web.config PATH = $website"
				$FIPSDOTNETConfigSettingsOutput += "#==================================================="
				}
			# This is not part of a STIG, but has a web.config file - changes below not tested for functionality
			#================================
			If ( ( gc web.config | select-string -pattern "symmetricAlgorithm iv=" ).Count -gt 0  )
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified SHA256 symmetric algorithm configuration"
				}
			If ( gc web.config | select-string -pattern "connection autoSignIn" ) 
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified connection autoSignIn configuration"
				}
			If ( ( gc web.config | select-string -pattern "machineKey validationKey" ).Count -gt 0 )
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified machineKey validationKey configuration"
				}
			If ( ( ( gc web.config | select-string -pattern "session encryptionKey" ) -AND ( gc web.config | select-string -pattern "SHA256" ) ).Count -gt 0 )
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified session encryptionKey and SHA256 token algorithm configuration"
				}
			If ( ( gc web.config | select-string -pattern "httpErrors errorMode" ).Count -gt 0 )
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified httpErrors errorMode Detailed debug configuration"
				}
			If ( ( gc web.config | select-string -pattern "DefaultErrorHandling" ).Count -gt 0 )
				{
				$FIPSDOTNETConfigSettingsOutput += "Verified DefaultErrorHandling configuration"
				}

			# Check for NULL missing entries
			#================================
			If ( $null -eq ( gc web.config | select-string -pattern "symmetricAlgorithm iv=" ) )
				{
				$FIPSDOTNETConfigSettingsOutput += "Missing SHA256 symmetric algorithm"
				If ( $null -ne ( gc web.config | select-string -pattern "symmetricAlgorithm" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# symmetricAlgorithm strings found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "symmetricAlgorithm"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			If ( $null -eq ( gc web.config | select-string -pattern "connection autoSignIn" ) ) 
				{
				$FIPSDOTNETConfigSettingsOutput += "Missing connection autoSignIn stanza"
				If ( $null -ne ( gc web.config | select-string -pattern "autoSignIn" ) ) 
					{
					$FIPSDOTNETConfigSettingsOutput += "# autoSignIn strings found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "autoSignIn"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			If ( ( ( gc web.config | select-string -pattern "machineKey" ) -OR ( gc web.config | select-string -pattern "validationKey" ) ).Count -gt 0 )
				{
				$FIPSDOTNETConfigSettingsOutput += "Missing machineKey validationKey stanza"
				If ( $null -ne ( gc web.config | select-string -pattern "machineKey validationKey" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# 'machineKey validationKey' string found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "machineKey validationKey"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			If ( $null -eq ( ( gc web.config | select-string -pattern "session encryptionKey" ) -AND ( gc web.config | select-string -pattern "SHA256" ) ) )
				{
				$FIPSDOTNETConfigSettingsOutput += "# Missing connection session encryptionKey stanza"
				If ( $null -ne ( gc web.config | select-string -pattern "session encryptionKey" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# Connection strings found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "session encryptionKey"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			If ( $null -eq ( gc web.config | select-string -pattern "httpErrors errorMode" ) )
				{
				$FIPSDOTNETConfigSettingsOutput += "Missing 'httpErrors errorMode Detailed' stanza"
				If ( $null -ne ( gc web.config | select-string -pattern "httpErrors errorMode" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# 'httpErrors errorMode' string found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "httpErrors errorMode"
					$FIPSDOTNETConfigSettingsOutput += ""
					$FIPSDOTNETConfigSettingsOutput += "Check Nathan Gau's blog to change web console settings, see URL https://nathangau.wordpress.com/2016/12/02/scom-2012-webconsole-and-fips-compatibility/"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			If ( $null -eq ( gc web.config | select-string -pattern "DefaultErrorHandling" ) )
				{
				$FIPSDOTNETConfigSettingsOutput += "Missing 'DefaultErrorHandling' stanza"
				If ( $null -ne ( gc web.config | select-string -pattern "DefaultErrorHandling" ) )
					{
					$FIPSDOTNETConfigSettingsOutput += "# 'DefaultErrorHandling' string found in web.config file"
					$FIPSDOTNETConfigSettingsOutput += "#===================================="
					$FIPSDOTNETConfigSettingsOutput += gc web.config | select-string -pattern "DefaultErrorHandling"
					$FIPSDOTNETConfigSettingsOutput += ""
					$FIPSDOTNETConfigSettingsOutput += "Check Kevin Holman's web console blog to change web console settings, see URL https://kevinholman.com/2020/09/15/how-to-change-web-console-defaults-in-scom-2019/"
					$FIPSDOTNETConfigSettingsOutput += ""
					}
				}
			}
			$FIPSDOTNETConfigSettingsOutput += ""
		}
	}

$FIPSDOTNETConfigSettingsOutput

$FIPSDOTNETConfigSettingsOutput = $FIPSDOTNETConfigSettingsOutput | out-string


#============================================================
$Result = "GOOD"
$momapi.LogScriptEvent($ScriptName,$EventID,0,"$FIPSDOTNETConfigSettingsOutput")

$bag.AddValue('Result',$Result)
#$bag.AddValue('Count',$Test)
#$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$FIPSDOTNETConfigSettingsOutput)


# Return all bags
$bag
#============================================================
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"SCOM FIPS WebConsole DOTNET Configuration Script Completed.  Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>

      <WriteActionModuleType ID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Alert.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Alert.WA.v1024.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather SCOMCore alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Alert.WA.v1024.ps1"
$EventID = "633"
#=================================================================================

# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"SCOM Core Alerts Close Script is starting.  Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-1)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather SCOMCore Alerts for date ($date).")
$Message = "Proactive DailyTasks SystemCenter Core Monitoring alerts for ($date)"

# Gather SCOMCore alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules


$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "System Center Core Monitoring"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreRuleAlerts

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMOpenReportAlerts = $SCOMCoreReportAlerts | ? { ( $_.ResolutionState -ne "255" ) }
$SCOMOpenReportAlerts.Count

$SCOMClosedReportAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -OR ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMClosedReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

$AutoClosed = $SCOMCoreMonitorAlerts.Count + $SCOMCoreRuleAlerts.Count
$Test = $SCOMCoreReportAlerts.Count


$momapi.LogScriptEvent($ScriptName,$EventID,0,"SCOMCore alerts gathered for ($date).")


# Agent resources alerts
$AgentResources = $SCOMCoreMonitorAlerts | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost*" ) }
$AgentResources.Count

if ( $AgentResources.Count -gt 0 )
	{
	# All
	$AgentResourcesFormatted = $AgentResources | ft TimeRaised,NetbiosComputerName,Description -auto -wrap
	# Break out variants MonitoringHost Private Bytes/Handle Count
	$PrivateBytes = $AgentResources | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost Private Bytes*" ) }
	$PrivateBytes.Count
	$HandleCount = $AgentResources | ? { ( $_.Name -like "Agent Resources Exceeded Threshold: MonitoringHost Handle Count*" ) }
	$HandleCount.Count

	# Operations Manager failed alerts
	$OpsMgrfailedAlerts = $SCOMCoreAlertsSinceLastReport | ? { ( $_.Name -like "Operations Manager failed*" ) `
		-AND ( $_.Description -like "*The paging file is too small*" )
		}
	$OpsMgrfailedAlerts.Count
	#$OpsMgrfailedAlerts | ft TimeRaised,NetbiosComputerName -auto -wrap
	}

# Debug - Tally and build display of $SCOMCoreReportAlerts
#$SCOMCoreAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,Description

# NOT Monitored server alerts
$NOTMonitoredServers = $SCOMCoreMonitorAlerts | ? { ( $_.Name -eq "Health Service Heartbeat Failure" ) }
$NOTMonitoredServers.Count

# Remaining alerts
$Remaining = @()
$Remaining = $SCOMCoreMonitorAlerts | ? { ( $_.Name -ne "Health Service Heartbeat Failure" ) `
	-AND ( $_.Name -notlike "Agent Resources Exceeded Threshold: MonitoringHost*" ) `
	}
$Remaining.Count


#
# Create table output
$SCOMCoreServerAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,TimeRaised,Name

#
# Create table output (no description)
$SCOMCoreServerAlerts = $SCOMCoreReportAlerts | select MonitoringObjectDisplayName,TimeRaised,Name

$Test = $SCOMCoreServerAlerts.count


#
# Build report
$SCOMCoreAMessage = @()


if ( $SCOMCoreReportAlerts.count -eq 0 )
	{
	$Message = "ZERO SCOMCore alerts auto-closed for ($date)"
	$SCOMCoreAMessage += "ZERO SCOMCore alerts auto-closed for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}


if ( $SCOMCoreReportAlerts.count -gt 0 )
	{
	$Message = "Proactive DailyTasks SCOMCore alerts auto-closed for ($date)"
	$SCOMCoreAMessage += $Message
	$SCOMCoreAMessage += ""
	$SCOMCoreAMessage += "Alert Count = $Test "
	$SCOMCoreAMessage += ""
	$SCOMCoreAMessage += "# SCOMCore alerts auto-closed"
	$SCOMCoreAMessage += "#=========================================================="
	$SCOMCoreAMessage += "# ALL SCOMCore alerts = $($SCOMCoreReportAlerts.Count)"
	$SCOMCoreAMessage += "#"
	$SCOMCoreAMessage += "# SCOMCore alerts since last report = $($SCOMCoreAlertsSinceLastReport.Count)"
	$SCOMCoreAMessage += "#"
	$SCOMCoreAMessage += "# Open SCOMCore alerts = $($SCOMOpenReportAlerts.Count)"
	$SCOMCoreAMessage += "# Closed SCOMCore alerts = $($SCOMClosedReportAlerts.Count)"
	$SCOMCoreAMessage += "#=========================================================="
	$SCOMCoreAMessage += "#"

	if ( $AgentResources.Count -gt 0 )
		{
		$SCOMCoreAMessage += "# Agent Resources alert breakdown"
		$SCOMCoreAMessage += "#================================================"
		$SCOMCoreAMessage += "# Agent Private Bytes alerts = $($PrivateBytes.Count)"
		$SCOMCoreAMessage += "# Agent Handle Count alerts = $($HandleCount.Count)"
		$SCOMCoreAMessage += "#"

		if ( ( $HandleCount.Count -gt 0 ) -AND ( $HandleCount.count -le 10 ) )
			{
			$SCOMCoreAMessage += "# Handle Count details"
			$SCOMCoreAMessage += $HandleCount | sort -property TimeRaised -desc | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( $HandleCount.Count -gt 10 )
			{
			$SCOMCoreAMessage += "More than 10 handle count alerts for report run get-scomalert for ALL details"
			$SCOMCoreAMessage += "First 10 alerts displayed"
			$SCOMCoreAMessage += $HandleCount | sort -property TimeRaised -desc | select -first 10 | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( ( $PrivateBytes.Count -gt 0 ) -AND ( $PrivateBytes.Count -le 10 ) )
			{
			$SCOMCoreAMessage += "# Private Bytes agent alert details"
			$SCOMCoreAMessage += $PrivateBytes | sort -property TimeRaised -desc | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		if ( $PrivateBytes.Count -gt 10 )
			{
			$SCOMCoreAMessage += "More than 10 private byte alerts for report run get-scomalert for more details"
			$SCOMCoreAMessage += "First 10 alerts displayed"
			$SCOMCoreAMessage += $PrivateBytes | sort -property TimeRaised -desc | select -first 10 | ft TimeRaised,NetbiosComputerName,Description -auto -wrap | out-string
			$SCOMCoreAMessage += ""
			}
		}
		if ( $OpsMgrfailedAlerts -gt 0 )
			{
			$SCOMCoreAMessage += "# OperationsManager and 'paging file is too small' alerts"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += $OpsMgrfailedAlerts | ft TimeRaised,NetbiosComputerName -auto -wrap | out-string
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			}
		if ( $Remaining.Count -gt 0 )
			{
			$SCOMCoreAMessage += "# Remaining alerts not classified"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += $Remaining | ft TimeRaised,MonitoringObjectDisplayName,Name -auto -wrap | out-string
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			}
		if ( $NOTMonitoredServers.Count -gt 0 )
			{
			$SCOMCoreAMessage += "# 'NOT monitored servers"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += "# 'NOT monitored server count = $($NOTMonitoredServers.Count)"
			$SCOMCoreAMessage += "#================================================"
			$SCOMCoreAMessage += ""
			if ( $NOTMonitoredServers.Count -gt 20 )
				{
				$SCOMCoreAMessage += "# 'NOT monitored servers greater than 20"
				}
			if ( $NOTMonitoredServers.Count -lt 20 )
				{
				$SCOMCoreAMessage += "# 'NOT monitored server detail"			
				$SCOMCoreAMessage += "#================================================"
				$SCOMCoreAMessage += $NOTMonitoredServers | ft TimeRaised,MonitoringObjectDisplayName -auto -wrap | out-string
				$SCOMCoreAMessage += "#================================================"
				}
			$SCOMCoreAMessage += ""
		$SCOMCoreAMessage += "#================================================"
		$SCOMCoreAMessage += "#"
			}
	}

$SCOMCoreAMessage

$SCOMCoreAMessage = $SCOMCoreAMessage | out-string


#============================================================


  $Result = "GOOD"
  #$Message = "SCOMCore Monitors auto-closed for ($date)"

  $momapi.LogScriptEvent($ScriptName,$EventID,0,"$SCOMCoreAMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$SCOMCoreAMessage)


# Return all bags
$bag
#============================================================


#
# If Cleanup needed, array of report monitors

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks SystemCenter Core Monitoring monitor reset begins for ($date).")


#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks SystemCenter Core Monitoring monitor reset started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get SCOM Core classes - $SCOMCoreMP

	# SCOMCore pack naming
	$SCOMCoreClasses = @(Get-SCOMClass -ManagementPack $SCOMCoreMP; )
	$SCOMCoreClass = $SCOMCoreClasses | sort -property Name -uniq
	# Debug
	$SCOMCoreClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $SCOMCoreClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count					
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#===================================
# $UnhealthyMonitors = $($UnhealthyMonitors | measure-object -sum).sum
#$momapi.LogScriptEvent($ScriptName,$EventID,0,"# Proactive DailyTasks SystemCenter Core Monitoring monitor reset auto-close completed on ($date).")
#=================================================================================

#
# (Rules) Alerts to auto close after reset monitor
#============================================================
# Resolve alerts after report built
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }

# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days

if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - Proactive System Center Core Monitoring Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"# Proactive System Center Core Monitoring Addendum rule closure completed for ($date).")


#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Proactive.SCOMCore.Repeated.Event.MonitorType" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="RepeatedEventRaised" NoDetection="false" />
          <MonitorTypeState ID="TimerEventRaised" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="LogName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ErrorExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AutoResolveInterval" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimerWindowInSeconds" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RepeatCount" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ErrorDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <LogName>$Config/LogName$</LogName>
            </DataSource>
            <ProbeAction ID="OnDemandReset" TypeID="System!System.PassThroughProbe" />
            <ConditionDetection ID="ErrorFilterCondition" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/ErrorExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="RepeatedDataCondition" TypeID="System!System.ConsolidatorCondition">
              <Consolidator>
                <ConsolidationProperties />
                <TimeControl>
                  <WithinTimeSchedule>
                    <Interval>$Config/TimerWindowInSeconds$</Interval>
                  </WithinTimeSchedule>
                </TimeControl>
                <CountingCondition>
                  <Count>$Config/RepeatCount$</Count>
                  <CountMode>OnNewItemTestOutputRestart_OnTimerSlideByOne</CountMode>
                </CountingCondition>
              </Consolidator>
            </ConditionDetection>
            <ConditionDetection ID="TimerCondition" TypeID="System!System.TimerCondition">
              <TimerWaitInSeconds>$Config/AutoResolveInterval$</TimerWaitInSeconds>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="RepeatedEventRaised">
              <Node ID="RepeatedDataCondition">
                <Node ID="ErrorFilterCondition">
                  <Node ID="ErrorDataSource" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="TimerCondition">
                <Node ID="RepeatedDataCondition">
                  <Node ID="ErrorFilterCondition">
                    <Node ID="ErrorDataSource" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="OnDemandReset" />
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="GoodCondition" NoDetection="false" />
          <MonitorTypeState ID="BadCondition" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="IntervalSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="0" type="xsd:string" name="SyncTime" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:string" name="StringParamExample" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:string" name="ComputerName" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
		  <xsd:element minOccurs="1" type="xsd:integer" name="MatchCount" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
		  <OverrideableParameter ID="IntervalSeconds" Selector="$Config/IntervalSeconds$" ParameterType="int" />
		  <OverrideableParameter ID="SyncTime" Selector="$Config/SyncTime$" ParameterType="string" />
		  <OverrideableParameter ID="StringParamExample" Selector="$Config/StringParamExample$" ParameterType="string" />
		  <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
		  <OverrideableParameter ID="MatchCount" Selector="$Config/MatchCount$" ParameterType="int" />		  
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.DS">
			  <IntervalSeconds>$Config/IntervalSeconds$</IntervalSeconds>
			  <SyncTime>$Config/SyncTime$</SyncTime>
			  <StringParamExample>$Config/StringParamExample$</StringParamExample>
			  <ComputerName>$Config/ComputerName$</ComputerName>
			  <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="GoodConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">GoodCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="BadConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">BadCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
			  <SuppressionSettings>
                <MatchCount>$Config/MatchCount$</MatchCount>
              </SuppressionSettings>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Discoveries>
      <Discovery ID="Proactive.High.Agent.Handle.Count.Servers.Group.Discovery" Enabled="true" Target="Proactive.High.Agent.Handle.Count.Servers.Group" ConfirmDelivery="false" Remotable="true" Priority="Normal">
        <Category>Discovery</Category>
        <DiscoveryTypes>
          <DiscoveryRelationship TypeID="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities" />
        </DiscoveryTypes>
        <DataSource ID="GroupPopulationDataSource" TypeID="SC!Microsoft.SystemCenter.GroupPopulator">
          <RuleId>$MPElement$</RuleId>
          <GroupInstanceId>$MPElement[Name="Proactive.High.Agent.Handle.Count.Servers.Group"]$</GroupInstanceId>
          <MembershipRules>
            <MembershipRule>
              <MonitoringClass>$MPElement[Name="SC!Microsoft.SystemCenter.Agent"]$</MonitoringClass>
              <RelationshipClass>$MPElement[Name="MSIGL!Microsoft.SystemCenter.InstanceGroupContainsEntities"]$</RelationshipClass>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <HostProperty>
                      <MonitoringClass>$MPElement[Name="Windows!Microsoft.Windows.Computer"]$</MonitoringClass>
                      <Property>$MPElement[Name="Windows!Microsoft.Windows.Computer"]/PrincipalName$</Property>
                    </HostProperty>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>(?i)a1d3|dd3</Pattern>
                </RegExExpression>
              </Expression>
            </MembershipRule>
          </MembershipRules>
        </DataSource>
      </Discovery>
    </Discoveries>
    <Rules>
      <Rule ID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.DataSource">
            <TimeoutSeconds>900</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">633</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>SCOMCore alerts auto-closed for </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>

      <Rule ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.Datasource">
            <IntervalSeconds>86380</IntervalSeconds>
            <SyncTime>05:31</SyncTime>
			<TimeoutSeconds>120</TimeoutSeconds>
		    <StringParamExample>D:\TOOLS\</StringParamExample>  <!-- Just an example of some string data to pass into the script -->
		    <ComputerName>LIBEW054AAK2OM2</ComputerName>  <!-- Might need to change the number of Host entries in this line depending on your target class -->
          </DataSource>
        </DataSources>
        <ConditionDetection ID="CD" TypeID="System!System.ExpressionFilter">
		  <Expression>
			<SimpleExpression>
				<ValueExpression>
				  <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
				</ValueExpression>
				<Operator>Equal</Operator>
				<ValueExpression>
				  <Value Type="String">BAD</Value>
				</ValueExpression>
			</SimpleExpression>
		  </Expression>
          <SuppressionSettings>
            <MatchCount>1</MatchCount>
          </SuppressionSettings>					
        </ConditionDetection>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>  <!-- 0=Low, 1=Medium, 2=High -->
            <Severity>1</Severity>  <!-- 0=Information, 1=Warning, 2=Critical -->
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Result']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Summary']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.ManagementServer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.DataSource">
            <TimeoutSeconds>300</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Result']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Summary']$</AlertParameter2>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Summary']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Alert.WA">
          <TimeoutSeconds>900</TimeoutSeconds>
        </WriteAction>
      </Task>
    </Tasks>
    <Monitors>
	  <UnitMonitor ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ParentMonitorID="Health!System.Health.AvailabilityState" Remotable="true" Priority="Normal" TypeID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.MonitorType" ConfirmDelivery="true">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>  <!-- Warning or Error should match OperationalStates below  -->
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>  <!-- Common options for AlertSeverity are MatchMonitorHealth, Information, Warning, Error -->
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Result']$</AlertParameter1> <!-- This is an example of passing property output from the script into the alert description -->
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="GoodCondition" MonitorTypeStateID="GoodCondition" HealthState="Success" />
          <OperationalState ID="BadCondition" MonitorTypeStateID="BadCondition" HealthState="Warning" />  <!-- HealthState = Warning or Error -->
        </OperationalStates>
        <Configuration>
          <IntervalSeconds>86300</IntervalSeconds>
		  <SyncTime>05:35</SyncTime>
		  <StringParamExample>D:\TOOLS\</StringParamExample>  <!-- Just an example of some string data to pass into the script -->
		  <ComputerName>LIBEW054AAK2OM2</ComputerName>  <!-- Might need to change the number of Host entries in this line depending on your target class -->
          <TimeoutSeconds>120</TimeoutSeconds>
		  <MatchCount>1</MatchCount>  <!-- This is the number of consecutive matches that must be met before the monitor will change state.  Also a good example of passing in Integer data. -->
        </Configuration>
      </UnitMonitor>
    </Monitors>
    <Overrides>
      <MonitorConfigurationOverride ID="Override.Group.Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold" Context="Proactive.High.Agent.Handle.Count.Servers.Group" ContextInstance="c9736e2d-16ad-7b18-ad65-c617a16e9720" Enforced="false" Monitor="SCCM!Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold" Parameter="Threshold">
        <Value>50000</Value>
      </MonitorConfigurationOverride>
      
	  <MonitorPropertyOverride ID="Override.Microsoft.SystemCenter.HealthService.SystemRulesLoaded" Context="SC!Microsoft.SystemCenter.HealthServiceWatcher" Enforced="false" Monitor="SCCM!Microsoft.SystemCenter.HealthService.SystemRulesLoaded" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Microsoft.SystemCenter.HealthServiceWatcher.HealthServiceAvailabilityState" Context="SC!Microsoft.SystemCenter.HealthServiceWatcher" Enforced="false" Monitor="SCCM!Microsoft.SystemCenter.HealthServiceWatcher.HealthServiceAvailabilityState" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.AutoResolve.Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Monitor="SCCM!Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold" Property="AutoResolve">
        <Value>true</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Microsoft.SystemCenter.HealthService.Heartbeat" Context="SC!Microsoft.SystemCenter.HealthServiceWatcher" Enforced="false" Monitor="SCCM!Microsoft.SystemCenter.HealthService.Heartbeat" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>

      <RuleConfigurationOverride ID="Override.Microsoft.SystemCenter.Alert.SuppressionReplacementFailure" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.Alert.SuppressionReplacementFailure" Parameter="Severity" Module="Alert">
        <Value>1</Value>
      </RuleConfigurationOverride>

      <RulePropertyOverride ID="Override.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedResponses" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedResponses" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.SystemCenter.PowerShellModule.AlertOnFailedResponses" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.PowerShellModule.AlertOnFailedResponses" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedInitialization" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedInitialization" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.SystemCenter.ServiceCheckDataSourceModule.FailedExecution.Alert" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ServiceCheckDataSourceModule.FailedExecution.Alert" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Microsoft.SystemCenter.SchedulerDSModule.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.SchedulerDSModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disabled.Microsoft.SystemCenter.RegistryProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.RegistryProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disabled.Microsoft.SystemCenter.Notification.EventCollection" Context="MSCNL!Microsoft.SystemCenter.AlertNotificationSubscriptionServer" Enforced="false" Rule="MSCNL!Microsoft.SystemCenter.Notification.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.HealthService.Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.HealthService.Microsoft.SystemCenter.WmiEventModule.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.WmiEventModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.HS.Microsoft.SystemCenter.HealthService.HealthManager.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.HealthService.HealthManager.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection.Rule" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedCreateProcess.Rule" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedCreateProcess" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.AgentManagement.CollectEndToEndEvent" Context="SC!Microsoft.SystemCenter.ManagementServer" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.AgentManagement.CollectEndToEndEvent" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.HealthService.Microsoft.SystemCenter.BackCompatModule.EventCollection" Context="SC!Microsoft.SystemCenter.HealthService" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BackCompatModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.DataAccessService.EventCollection" Context="SystemCenter!Microsoft.SystemCenter.ManagementDataAccessService" Enforced="false" Rule="SystemCenter!Microsoft.SystemCenter.DataAccessService.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.ConsolidatorModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ConsolidatorModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.MOM2005ApplogReaderModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.MOM2005ApplogReaderModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.WmiEventModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.WmiEventModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.IISSiteStateDataSourceModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.IISSiteStateDataSourceModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.HealthService.ConfigurationParseError.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.HealthService.ConfigurationParseError.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.AlertSubscriptionModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.AlertSubscriptionModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.HealthService.EntityStateChangeFlow.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.HealthService.EntityStateChangeFlow.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.IISLogConditionModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.IISLogConditionModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.BackCompatModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BackCompatModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.SchedulerConModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.SchedulerConModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.CorrelatorModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.CorrelatorModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.ApplicationLog.Syslog.Modules.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ApplicationLog.Syslog.Modules.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.LDAPProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.LDAPProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.AgentRecovery.FailedToStart" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.AgentRecovery.FailedToStart" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.BatchResponseModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.BatchResponseModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.IISDiscoveryProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.IISDiscoveryProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.ComputerVerification.Modules.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ComputerVerification.Modules.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.AppLogModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.AppLogModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.DependentServiceCheckProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.DependentServiceCheckProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.HealthService.HealthManager.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.HealthService.HealthManager.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.PowerShellModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.PowerShellModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.WmiProbeModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.WmiProbeModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.TimerConModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.TimerConModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
      <RulePropertyOverride ID="Override.Disable.Microsoft.SystemCenter.ServiceCheckDataSourceModule.EventCollection" Context="SC!Microsoft.SystemCenter.Agent" Enforced="false" Rule="SCCM!Microsoft.SystemCenter.ServiceCheckDataSourceModule.EventCollection" Property="Enabled">
        <Value>false</Value>
      </RulePropertyOverride>
    </Overrides>
  </Monitoring>
  <Presentation>
    <StringResources>
      <StringResource ID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Alert.Rule.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="false">
      <DisplayStrings>
        <DisplayString ElementID="Proactive.Microsoft.System.Center.Core.Monitoring.Addendum">
          <Name>Proactive Microsoft System Center Core Monitoring Addendum</Name>
          <Description>
v1.0.2.4  13 Aug 2025 SCOM STIG V-237439 FIPS Compliance workflow DS/rule/alert
v1.0.2.3  19 Nov 2024 DWDataRP, Report and Close report changes
v1.0.2.2  18 Oct 2024 Renumber events.  Updated overrides, DWDataRP executable rule/monitor DS with overrides, disabled event collection
v1.0.1.8  21 Dec 2023 Updated Monitor/Rule closure logic, whitespace audit
v1.0.1.6  18 Jul 2023 Added override to pack
v1.0.1.5  27 Jun 2023 Reports updated to informational, Event collection rule added
v1.0.1.4   7 Feb 2023 Updated with cleanup with Remaining and other alert breakdowns
v1.0.1.3  23 Jan 2023 Updated with MP methods, updated DS/WA reports
v1.0.1.2   5 Jan 2023 Event collection disabled
v1.0.0.9  21 Apr 2022 Updated Core Monitoring for handle alerts
v1.0.0.6   8 Feb 2022 Added 'Management Configuration Service group' alert
v1.0.0.5  10 Dec 2021 Updated ft to select, re-wrote report for agent threshold, paging, and other errors
v1.0.0.1   4 May 2021 Updated DS and WA with additional logging, build report first, then cleanup
v1.0.0.0   6 Apr 2021 Created management pack for SCOM Core mgmt pack auto closure cleanup</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.High.Agent.Handle.Count.Servers.Group">
          <Name>Proactive High Agent Handle Count servers</Name>
          <Description>Created 21 Apr 2022 - KWJ - Agent Handle count over 30k to get in this group</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.DataSource">
          <Name>Proactive DailyTasks SCOMCoreAlerts report and auto-close DataSource</Name>
          <Description>This datasource generates SCOMCoreAlerts report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.DS">
          <Name>Proactive DailyTasks SCOMCoreAlerts DWDataRP Monitor Script DataSource</Name>
          <Description>This datasource generates SCOMCoreAlerts DWDataRP script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.Datasource">
          <Name>Proactive DailyTasks SCOMCoreAlerts DWDataRP Rule Script DataSource</Name>
          <Description>This datasource generates SCOMCoreAlerts DWDataRP Rule script DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Datasource">
          <Name>Proactive DailyTasks SCOMCoreAlerts FIPS Compliance Script DataSource</Name>
          <Description>This datasource generates SCOMCoreAlerts FIPS Compliance Script Rule DataSource</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Close.Script.Alert.WA">
          <Name>Proactive DailyTasks SCOMCoreAlerts report and auto-close on-demand task</Name>
          <Description>This write-action task generates SCOMCoreAlerts report and auto-close DataSource</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.High.Agent.Handle.Count.Servers.Group.Discovery">
          <Name>Populate Proactive High Agent Handle Count servers</Name>
          <Description>This discovery rule populates the group 'DTRA High Agent Handle Count servers'</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks SCOMCoreAlerts Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0615 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks SCOMCoreAlerts Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks SCOMCoreAlerts task Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task.Rule.AlertMessage">
          <Name>Proactive DailyTasks SCOMCoreAlerts Report Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule">
          <Name>Proactive DailyTasks SCOMCoreAlerts DWDataRP Script Alert Rule</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule" SubElementID="DS">
          <Name>Proactive DailyTasks SCOMCoreAlerts DWDataRP Rule Script DataSource</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule" SubElementID="WA">
          <Name>WA</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule" SubElementID="CD">
          <Name>CD</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks SCOMCoreAlerts DWDataRP Script Alert Rule Triggered</Name>
          <Description>Proactive DailyTasks SCOMCoreAlerts DWDataRP Script Alert Rule
{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Alert.Rule">
          <Name>Proactive DailyTasks SCOMCoreAlerts FIPS Compliance Script Alert Rule</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.FIPS.Compliance.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks SCOMCoreAlerts FIPS Compliance Script Alert Rule</Name>
          <Description>Proactive DailyTasks SCOMCoreAlerts FIPS STIG V-237439 Compliance Script Alert Rule
{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.Report.Script.Task">
          <Name>Proactive DailyTasks SCOMCoreAlerts Autoclose Report Script Task</Name>
          <Description>Proactive DailyTasks SCOMCoreAlerts AutoClose task to kick off on-demand</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor">
          <Name>Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP Monitor</Name>
          <Description></Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor" SubElementID="GoodCondition">
          <Name>Good Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor" SubElementID="BadCondition">
          <Name>Bad Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP.Monitor.AlertMessage">
          <Name>Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP Monitor: Failure</Name>
          <Description>Proactive.DailyTasks.SCOMCoreAlerts.DWDataRP Monitor: detected a bad condition
Result: {0}</Description>
        </DisplayString>

        <DisplayString ElementID="Override.Microsoft.SystemCenter.HealthService.SystemRulesLoaded">
          <Name>NotUsed</Name>
          <Description>2 Apr 2020 - KWJ - Changing severity to warning for unloaded workflows alert</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.HealthServiceWatcher.HealthServiceAvailabilityState">
          <Name>NotUsed</Name>
          <Description>Created 1 Apr 2020 - Tuned to warning.  Agent down is not a critical 'wake me up' scenario</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Group.Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold">
          <Name>NotUsed</Name>
          <Description>50k on 13 June 2022
43k on 8 June 2022
39k on 7 June 2022
37k on 23 May 2022
36k on 11 May 2022
35k on  9 May 2022
33.5k on 27 Apr 2022
Created 8 Apr 2020 - high scom agent handle counts</Description>
        </DisplayString>
        <DisplayString ElementID="Override.AutoResolve.Microsoft.SystemCenter.Agent.MonitoringHost.HandleCountThreshold">
          <Name>NotUsed</Name>
          <Description>8 Apr 2020 - Adding alert auto-resolve override</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.HealthService.Heartbeat">
          <Name>NotUsed</Name>
          <Description>28 Sept 2020 - KWJ - Changed from critical to warning</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.Alert.SuppressionReplacementFailure">
          <Name>NotUsed</Name>
          <Description>13 Nov 2020 - KWJ - Setting to Warning</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedResponses">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling rule for alert noise</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.PowerShellModule.AlertOnFailedResponses">
          <Name>NotUsed</Name>
          <Description>22 Jan 2021 - KWJ - Disabling rule for alert noise</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedInitialization">
          <Name>NotUsed</Name>
          <Description>28 Jan 2021 - KWJ - Disabling alert</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.ServiceCheckDataSourceModule.FailedExecution.Alert">
          <Name>NotUsed</Name>
          <Description>28 Jan 2021 - KWJ - Disabling alert</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Microsoft.SystemCenter.SchedulerDSModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>17 Jun 2022 - KWJ - Disabled event collection rules</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disabled.Microsoft.SystemCenter.RegistryProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>5 Jan 2023 - KWJ - Disabling event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disabled.Microsoft.SystemCenter.Notification.EventCollection">
          <Name>NotUsed</Name>
          <Description>5 Jan 2023 - KWJ - Disabling event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.HealthService.Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>5 Jan 2023 - KWJ - Disabling event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.HealthService.Microsoft.SystemCenter.WmiEventModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>5 Jan 2023 - KWJ - Disabling event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.HS.Microsoft.SystemCenter.HealthService.HealthManager.EventCollection">
          <Name>NotUsed</Name>
          <Description>5 Jan 2023 - KWJ - Disabling event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection.Rule">
          <Name>NotUsed</Name>
          <Description>27 June 2023 - Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.BatchResponseModule.AlertOnFailedCreateProcess.Rule">
          <Name>NotUsed</Name>
          <Description>13 Jul 2023 - Disabling rule</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.AgentManagement.CollectEndToEndEvent">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabled event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.HealthService.Microsoft.SystemCenter.BackCompatModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disable Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.DataAccessService.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.ConsolidatorModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.MOM2005ApplogReaderModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.WmiEventModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.IISSiteStateDataSourceModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.HealthService.ConfigurationParseError.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.AlertSubscriptionModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.HealthService.EntityStateChangeFlow.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.IISLogConditionModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.BackCompatModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.SchedulerConModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.CorrelatorModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.ApplicationLog.Syslog.Modules.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.LDAPProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.AgentRecovery.FailedToStart">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.BatchResponseModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.IISDiscoveryProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.ComputerVerification.Modules.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.AppLogModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.DependentServiceCheckProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.HealthService.HealthManager.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.WmiRawPerfCounterModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.ServiceCheckProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 - Disabling Event Collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.PowerShellModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.WmiProbeModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.TimerConModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 Disabling Event collection</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Disable.Microsoft.SystemCenter.ServiceCheckDataSourceModule.EventCollection">
          <Name>NotUsed</Name>
          <Description>18 Oct 2024 Disabling Event collection</Description>
        </DisplayString>
      </DisplayStrings>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>